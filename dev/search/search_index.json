{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"from jackie.router import Router from jackie.http import TextResponse app = Router () @app . get ( '/' ) async def hello_world ( request ): name = request . query . get ( 'name' , 'World' ) return TextResponse ( f 'Hello, { name } !' )","title":"Home"},{"location":"changelog/","text":"Changelog All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . Unreleased Added jackie.http.Cookie is a new class that contains information about setting a cookie. It takes a name and a value but also parameters like expires and same_site . jackie.http.Request now has an attribute cookies that contains a dict of cookies. jackie.http.Response now takes a keyword argument set_cookies which accepts an iterable of jackie.http.Cookie . These cookies will be added to the response headers as Set-Cookie -headers. jackie.http.Socket now has an attribute cookies that contains a dict of cookies. jackie.http.Socket.accept now takes a keyword argument set_cookies which accepts an iterable of jackie.http.Cookie . These cookies will be added to the response headers as Set-Cookie -headers. jackie.client.Client now has a cookies attribute that contains a dict of cookies. These are automatically sent as a Cookie -header on requests and modified by Set-Cookie -headers on responses. jackie.router.Router now has a websocket_not_found method that sets a view for when no view could be found for a websocket connection. 0.1.0 - 2021-02-16 Added A HTTP API using Request and Response objects or a Socket object in case of websockets that can be used interchangably with ASGI because of the functions jackie_to_asgi and asgi_to_jackie that allow conversion between the two. A Router class that makes it easy to create a routed ASGI application that uses the HTTP API described above for the implementation of it's endpoints. A Client that makes it easy to interact with ASGI applications for purposes like testing.","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#unreleased","text":"","title":"Unreleased"},{"location":"changelog/#added","text":"jackie.http.Cookie is a new class that contains information about setting a cookie. It takes a name and a value but also parameters like expires and same_site . jackie.http.Request now has an attribute cookies that contains a dict of cookies. jackie.http.Response now takes a keyword argument set_cookies which accepts an iterable of jackie.http.Cookie . These cookies will be added to the response headers as Set-Cookie -headers. jackie.http.Socket now has an attribute cookies that contains a dict of cookies. jackie.http.Socket.accept now takes a keyword argument set_cookies which accepts an iterable of jackie.http.Cookie . These cookies will be added to the response headers as Set-Cookie -headers. jackie.client.Client now has a cookies attribute that contains a dict of cookies. These are automatically sent as a Cookie -header on requests and modified by Set-Cookie -headers on responses. jackie.router.Router now has a websocket_not_found method that sets a view for when no view could be found for a websocket connection.","title":"Added"},{"location":"changelog/#010-2021-02-16","text":"","title":"0.1.0 - 2021-02-16"},{"location":"changelog/#added_1","text":"A HTTP API using Request and Response objects or a Socket object in case of websockets that can be used interchangably with ASGI because of the functions jackie_to_asgi and asgi_to_jackie that allow conversion between the two. A Router class that makes it easy to create a routed ASGI application that uses the HTTP API described above for the implementation of it's endpoints. A Client that makes it easy to interact with ASGI applications for purposes like testing.","title":"Added"},{"location":"quick-start/deployment/","text":"Deployment Jackie apps implements the ASGI protocol, this means that they can be served by any ASGI server. You can find a list of ASGI servers here .","title":"Deployment"},{"location":"quick-start/deployment/#deployment","text":"Jackie apps implements the ASGI protocol, this means that they can be served by any ASGI server. You can find a list of ASGI servers here .","title":"Deployment"},{"location":"quick-start/hello-world/","text":"Hello World Here we provide a simple 'Hello, World!'-example: from jackie.router import Router from jackie.http import TextResponse app = Router () @app . get ( '/' ) def hello_world ( request ): name = request . query . get ( 'name' , 'World' ) return TextResponse ( f 'Hello, { name } !' ) We start with creating a Router , this router is used to send requests to the correct view based on the method and path of the request. The hello_world -function is what we call a 'view'. This is a function that accepts a request and returns a response. In this case we either get the name from the query params or default to 'World' .","title":"Hello World"},{"location":"quick-start/hello-world/#hello-world","text":"Here we provide a simple 'Hello, World!'-example: from jackie.router import Router from jackie.http import TextResponse app = Router () @app . get ( '/' ) def hello_world ( request ): name = request . query . get ( 'name' , 'World' ) return TextResponse ( f 'Hello, { name } !' ) We start with creating a Router , this router is used to send requests to the correct view based on the method and path of the request. The hello_world -function is what we call a 'view'. This is a function that accepts a request and returns a response. In this case we either get the name from the query params or default to 'World' .","title":"Hello World"},{"location":"quick-start/installation/","text":"Installation You can install jackie using pip . pip install jackie","title":"Installation"},{"location":"quick-start/installation/#installation","text":"You can install jackie using pip . pip install jackie","title":"Installation"},{"location":"reference/client/","text":"This module provides a client that can be used to interact with an ASGI application using a simple API. Client class Client(app) Initializes a client for the provided ASGI app app . Attributes cookies A dict mapping str to Cookie containing the cookies set by the app. These cookies are sent as a Cookie -header on requests and modified by Set-Cookie -headers on responses. Methods request coroutine request(path='/', *, form, method='GET', query=[], headers=[], **headers) coroutine request(path='/', *, json, method='GET', query=[], headers=[], **headers) coroutine request(path='/', *, text, method='GET', query=[], headers=[], **headers) coroutine request(path='/', *, body=b'', method='GET', query=[], headers=[], **headers) Returns a response of type Response from the app for a request described by the arguments. Both query and headers expect a dict , an iterable of 2-tuples or a MultiDict . There are 4 parameters that can describe the body of the request. form , json , text or body . At most one of these can be supplied and they determine whether the request will be a FormRequest , JsonRequest , TextRequest or Request respectively. get coroutine get(path='/', *, form, method='GET', query=[], headers=[], **headers) coroutine get(path='/', *, json, method='GET', query=[], headers=[], **headers) coroutine get(path='/', *, text, method='GET', query=[], headers=[], **headers) coroutine get(path='/', *, body=b'', method='GET', query=[], headers=[], **headers) Shorthand for request where method defaults to 'GET' . head coroutine head(path='/', *, form, method='GET', query=[], headers=[], **headers) coroutine head(path='/', *, json, method='GET', query=[], headers=[], **headers) coroutine head(path='/', *, text, method='GET', query=[], headers=[], **headers) coroutine head(path='/', *, body=b'', method='GET', query=[], headers=[], **headers) Shorthand for request where method defaults to 'HEAD' . post coroutine post(path='/', *, form, method='GET', query=[], headers=[], **headers) coroutine post(path='/', *, json, method='GET', query=[], headers=[], **headers) coroutine post(path='/', *, text, method='GET', query=[], headers=[], **headers) coroutine post(path='/', *, body=b'', method='GET', query=[], headers=[], **headers) Shorthand for request where method defaults to 'POST' . put coroutine put(path='/', *, form, method='GET', query=[], headers=[], **headers) coroutine put(path='/', *, json, method='GET', query=[], headers=[], **headers) coroutine put(path='/', *, text, method='GET', query=[], headers=[], **headers) coroutine put(path='/', *, body=b'', method='GET', query=[], headers=[], **headers) Shorthand for request where method defaults to 'PUT' . delete coroutine delete(path='/', *, form, method='GET', query=[], headers=[], **headers) coroutine delete(path='/', *, json, method='GET', query=[], headers=[], **headers) coroutine delete(path='/', *, text, method='GET', query=[], headers=[], **headers) coroutine delete(path='/', *, body=b'', method='GET', query=[], headers=[], **headers) Shorthand for request where method defaults to 'DELETE' . connect coroutine connect(path='/', *, form, method='GET', query=[], headers=[], **headers) coroutine connect(path='/', *, json, method='GET', query=[], headers=[], **headers) coroutine connect(path='/', *, text, method='GET', query=[], headers=[], **headers) coroutine connect(path='/', *, body=b'', method='GET', query=[], headers=[], **headers) Shorthand for request where method defaults to 'CONNECT' . options coroutine options(path='/', *, form, method='GET', query=[], headers=[], **headers) coroutine options(path='/', *, json, method='GET', query=[], headers=[], **headers) coroutine options(path='/', *, text, method='GET', query=[], headers=[], **headers) coroutine options(path='/', *, body=b'', method='GET', query=[], headers=[], **headers) Shorthand for request where method defaults to 'OPTIONS' . trace coroutine trace(path='/', *, form, method='GET', query=[], headers=[], **headers) coroutine trace(path='/', *, json, method='GET', query=[], headers=[], **headers) coroutine trace(path='/', *, text, method='GET', query=[], headers=[], **headers) coroutine trace(path='/', *, body=b'', method='GET', query=[], headers=[], **headers) Shorthand for request where method defaults to 'TRACE' . patch coroutine patch(path='/', *, form, method='GET', query=[], headers=[], **headers) coroutine patch(path='/', *, json, method='GET', query=[], headers=[], **headers) coroutine patch(path='/', *, text, method='GET', query=[], headers=[], **headers) coroutine patch(path='/', *, body=b'', method='GET', query=[], headers=[], **headers) Shorthand for request where method defaults to 'PATCH' . websocket coroutine websocket(path='/', *, query=[], headers=[], **headers) Returns a socket of type Socket with a websocket connection to the app described by the arguments. Both query and headers expect a dict , an iterable of 2-tuples or a MultiDict . The returned socket differes from a normal Socket in a few aspects because it resembles the other side of the connection. The accept coroutine will throw an error when called since it is not up to this socket to accept. This is the responsibility of the app. There are two extra coroutines called accepted and closed to be able to wait on the app to respectively accept or close the connection. accepted will return the response headers if accepted and otherwise throw a Disconnect . closed will return the close code if closed and otherwise throw an AssertionError.","title":"jackie.client"},{"location":"reference/client/#client","text":"class Client(app) Initializes a client for the provided ASGI app app .","title":"Client"},{"location":"reference/client/#attributes","text":"","title":"Attributes"},{"location":"reference/client/#cookies","text":"A dict mapping str to Cookie containing the cookies set by the app. These cookies are sent as a Cookie -header on requests and modified by Set-Cookie -headers on responses.","title":"cookies"},{"location":"reference/client/#methods","text":"","title":"Methods"},{"location":"reference/client/#request","text":"coroutine request(path='/', *, form, method='GET', query=[], headers=[], **headers) coroutine request(path='/', *, json, method='GET', query=[], headers=[], **headers) coroutine request(path='/', *, text, method='GET', query=[], headers=[], **headers) coroutine request(path='/', *, body=b'', method='GET', query=[], headers=[], **headers) Returns a response of type Response from the app for a request described by the arguments. Both query and headers expect a dict , an iterable of 2-tuples or a MultiDict . There are 4 parameters that can describe the body of the request. form , json , text or body . At most one of these can be supplied and they determine whether the request will be a FormRequest , JsonRequest , TextRequest or Request respectively.","title":"request"},{"location":"reference/client/#get","text":"coroutine get(path='/', *, form, method='GET', query=[], headers=[], **headers) coroutine get(path='/', *, json, method='GET', query=[], headers=[], **headers) coroutine get(path='/', *, text, method='GET', query=[], headers=[], **headers) coroutine get(path='/', *, body=b'', method='GET', query=[], headers=[], **headers) Shorthand for request where method defaults to 'GET' .","title":"get"},{"location":"reference/client/#head","text":"coroutine head(path='/', *, form, method='GET', query=[], headers=[], **headers) coroutine head(path='/', *, json, method='GET', query=[], headers=[], **headers) coroutine head(path='/', *, text, method='GET', query=[], headers=[], **headers) coroutine head(path='/', *, body=b'', method='GET', query=[], headers=[], **headers) Shorthand for request where method defaults to 'HEAD' .","title":"head"},{"location":"reference/client/#post","text":"coroutine post(path='/', *, form, method='GET', query=[], headers=[], **headers) coroutine post(path='/', *, json, method='GET', query=[], headers=[], **headers) coroutine post(path='/', *, text, method='GET', query=[], headers=[], **headers) coroutine post(path='/', *, body=b'', method='GET', query=[], headers=[], **headers) Shorthand for request where method defaults to 'POST' .","title":"post"},{"location":"reference/client/#put","text":"coroutine put(path='/', *, form, method='GET', query=[], headers=[], **headers) coroutine put(path='/', *, json, method='GET', query=[], headers=[], **headers) coroutine put(path='/', *, text, method='GET', query=[], headers=[], **headers) coroutine put(path='/', *, body=b'', method='GET', query=[], headers=[], **headers) Shorthand for request where method defaults to 'PUT' .","title":"put"},{"location":"reference/client/#delete","text":"coroutine delete(path='/', *, form, method='GET', query=[], headers=[], **headers) coroutine delete(path='/', *, json, method='GET', query=[], headers=[], **headers) coroutine delete(path='/', *, text, method='GET', query=[], headers=[], **headers) coroutine delete(path='/', *, body=b'', method='GET', query=[], headers=[], **headers) Shorthand for request where method defaults to 'DELETE' .","title":"delete"},{"location":"reference/client/#connect","text":"coroutine connect(path='/', *, form, method='GET', query=[], headers=[], **headers) coroutine connect(path='/', *, json, method='GET', query=[], headers=[], **headers) coroutine connect(path='/', *, text, method='GET', query=[], headers=[], **headers) coroutine connect(path='/', *, body=b'', method='GET', query=[], headers=[], **headers) Shorthand for request where method defaults to 'CONNECT' .","title":"connect"},{"location":"reference/client/#options","text":"coroutine options(path='/', *, form, method='GET', query=[], headers=[], **headers) coroutine options(path='/', *, json, method='GET', query=[], headers=[], **headers) coroutine options(path='/', *, text, method='GET', query=[], headers=[], **headers) coroutine options(path='/', *, body=b'', method='GET', query=[], headers=[], **headers) Shorthand for request where method defaults to 'OPTIONS' .","title":"options"},{"location":"reference/client/#trace","text":"coroutine trace(path='/', *, form, method='GET', query=[], headers=[], **headers) coroutine trace(path='/', *, json, method='GET', query=[], headers=[], **headers) coroutine trace(path='/', *, text, method='GET', query=[], headers=[], **headers) coroutine trace(path='/', *, body=b'', method='GET', query=[], headers=[], **headers) Shorthand for request where method defaults to 'TRACE' .","title":"trace"},{"location":"reference/client/#patch","text":"coroutine patch(path='/', *, form, method='GET', query=[], headers=[], **headers) coroutine patch(path='/', *, json, method='GET', query=[], headers=[], **headers) coroutine patch(path='/', *, text, method='GET', query=[], headers=[], **headers) coroutine patch(path='/', *, body=b'', method='GET', query=[], headers=[], **headers) Shorthand for request where method defaults to 'PATCH' .","title":"patch"},{"location":"reference/client/#websocket","text":"coroutine websocket(path='/', *, query=[], headers=[], **headers) Returns a socket of type Socket with a websocket connection to the app described by the arguments. Both query and headers expect a dict , an iterable of 2-tuples or a MultiDict . The returned socket differes from a normal Socket in a few aspects because it resembles the other side of the connection. The accept coroutine will throw an error when called since it is not up to this socket to accept. This is the responsibility of the app. There are two extra coroutines called accepted and closed to be able to wait on the app to respectively accept or close the connection. accepted will return the response headers if accepted and otherwise throw a Disconnect . closed will return the close code if closed and otherwise throw an AssertionError.","title":"websocket"},{"location":"reference/http/","text":"This module provides the building blocks to work with HTTP in jackie. Request class Request(path='/', *, method='GET', body=b'', query=[], headers=[], **headers) Represents a request from a client to the application. Both query and headers expect a dict , an iterable of 2-tuples or a MultiDict . body can be bytes , an iterable of bytes or an async iterable of bytes . This class implements Stream . Attributes method A string representing the HTTP request method of the request. This is always in uppercase. path A string representing the path that was requested. headers A Headers object containing all request headers. cookies A dict mapping str to str containing the cookies sent by the client. FormRequest class FormRequest(path='/', body={}, boundary=None, *, method='GET', query=[], headers=[], **headers) A subclass of Request that encodes the provided body as multipart/form-data and sets the appropriate headers. Body must be a dict , an iterable of 2-tuples or a MultiDict where the keys are strings and the values are either strings or a File . If no boundary is supplied a boundary is automatically generated. JsonRequest class JsonRequest(path='/', body={}, *, method='GET', query=[], headers=[], **headers) A subclass of Request that encodes the provided body as application/json and sets the appropriate headers. Body must be data that is JSON-encodable. TextRequest class TextRequest(path='/', body='', *, method='GET', query=[], headers=[], **headers) A subclass of Request that encodes the provided body as text/plain and sets the appropriate headers. Body must be a string. Response class Response(body=b'', *, status=200, content_type=None, charset=None, boundary=None, set_cookies=[], headers=[], **headers) Represents a response from the application to a client. Both query and headers expect a dict , an iterable of 2-tuples or a MultiDict . body can be bytes , an iterable of bytes or an async iterable of bytes . set_cookies expects an iterable of Cookie that will be added as Set-Cookie response headers. content_type , charset and boundary together determine the Content-Type header. If content_type starts with 'multipart/' we expect boundary to be present and add it to the Content-Type , otherwise charset gets added if present. This class implements Stream . Attributes status An integer representing the HTTP status code of the response. headers A Headers object containing all response headers. ok A boolean indicating whether the response is considered 'ok' according to the HTTP status code. This is implemented as status < 400 . FormResponse class FormResponse(body={}, boundary=None, *, status=200, content_type=None, charset=None, set_cookies=[], headers=[], **headers) A subclass of Response that encodes the provided body as multipart/form-data and sets the appropriate headers. Body must be a dict , an iterable of 2-tuples or a MultiDict where the keys are strings and the values are either strings or a File . If no boundary is supplied a boundary is automatically generated. HtmlResponse class HtmlResponse(body='', *, status=200, content_type=None, charset=None, set_cookies=[], headers=[], **headers) A subclass of Response that encodes the provided body as text/html and sets the appropriate headers. Body must be a string. JsonResponse class JsonResponse(body={}, *, status=200, content_type=None, charset=None, set_cookies=[], headers=[], **headers) A subclass of Response that encodes the provided body as application/json and sets the appropriate headers. Body must be data that is JSON-encodable. RedirectResponse class RedirectResponse(location, *, status=304, content_type=None, charset=None, set_cookies=[], headers=[], **headers) A subclass of Response that represents a redirect to the provided location . TextResponse class Response(body='', *, status=200, content_type=None, charset=None, set_cookies=[], headers=[], **headers) A subclass of Response that encodes the provided body as text/plain and sets the appropriate headers. Body must be a string. Stream class Stream(chunks=b'') This is an abstract base class that represents something with a stream of binary data and a content type. It is mainly used as base class for both Request and Response . Attributes content_type The basic content type without any metadata like the charset. charset The charset of the content. boundary The boundary of the content. This is mostly relevant for multipart content types. Methods chunks method chunks() Returns an async iterator of chunks of data. These chunks will be of type bytes . body coroutine body() Returns the contents of the stream as bytes . text Returns the contents of the stream as a string. json Returns the contents of the stream parsed as json. form Returns the contents of the stream parsed as form data. How the stream is parsed is dependent on the content_type , both application/x-www-form-urlencoded and multipart/form-data are supported. Socket class Socket(path='/', *, accept, close, receive, send, query=[], headers=[], **headers) Represents a websocket connection from a client to the application. Both query and headers expect a dict , an iterable of 2-tuples or a MultiDict . accept , close , receive , and send should be coroutines that respectively accept the connection, close the connection, receive a message from the socket or send a message to the socket. Attributes method This will always be equal to 'websocket' . This attribute is present to easily differentiate between Socket s and Request s. path A string representing the path that was requested. headers A Headers object containing all request headers. cookies A dict mapping str to str containing the cookies sent by the client. Methods accept coroutine accept(headers=[], set_cookies=[], **headers) Accepts the connection with the provided response headers. headers expects a dict , an iterable of 2-tuples or a MultiDict . set_cookies expects an iterable of Cookie that will be added as Set-Cookie response headers. close coroutine close(code=1000) Closes the connection with the provided code . receive_bytes coroutine receive_bytes() Receive a message from the socket as bytes . receive_text coroutine receive_text() Receive a message from the socket as str . receive_json coroutine receive_bytes() Receive a message from the socket as parsed json. send_bytes coroutine send_bytes(data) Sends data over the socket. data must be bytes . send_text coroutine send_bytes(data) Sends data over the socket. data must be str . send_json coroutine send_bytes(data) Sends data over the socket as JSON. data must be JSON encodable. Cookie Cookie(name, value, *, expires=None, max_age=None, domain=None, path=None, secure=False, http_only=False, same_site=None) Represents a cookie that can be set. expires must be a timezone aware datetime or None . max_age must be an integer or None . domain must be a str or None . path must be a str or None . same_site must be one of 'lax' , 'strict' , 'none' or None . Attributes expires A datetime indicating when the cookie will expire. Can also equal None in which case the cookie will expire at the end of the session. max_age An int indicating when the cookie will expire. The cookie will expire max_age seconds after receival. Can also equal None in which case the cookie will expire at the end of the session. domain The domain for which the cookie should be set as a str . Can also equal None in which case the current domain will be used. path The path for which the cookie should be set. Can also equal None in which case the root will be used. same_site A value indicating when to send the cookie. There are 3 options: strict , which means the cookie will only be sent on requests originating from the domain/path the cookie belongs to itself. lax , which is similar to strict but also includes the cookie when a user navigates to the domain/path. none , which does no checking on the origin of the request. Can also equal None in which case the cookie will behave as lax . On older clients the behaviour of none will be used instead when no value is present. Methods encode method encode() Returns a str of the cookie encoded as the value of Set-Cookie -header. Disconnect class Disconnect(code=None) An exception that represents an HTTP Disconnect. Attributes code The websocket close code in a websocket context, otherwise None . asgi_to_jackie asgi_to_jackie(app) Converts an ASGI application app into a jackie view. If app was created by jackie_to_asgi it will return the original view instead. jackie_to_asgi asgi_to_jackie(view) Converts a jackie view view into an ASGI application. If view was created by asgi_to_jackie it will return the original application instead.","title":"jackie.http"},{"location":"reference/http/#request","text":"class Request(path='/', *, method='GET', body=b'', query=[], headers=[], **headers) Represents a request from a client to the application. Both query and headers expect a dict , an iterable of 2-tuples or a MultiDict . body can be bytes , an iterable of bytes or an async iterable of bytes . This class implements Stream .","title":"Request"},{"location":"reference/http/#attributes","text":"","title":"Attributes"},{"location":"reference/http/#method","text":"A string representing the HTTP request method of the request. This is always in uppercase.","title":"method"},{"location":"reference/http/#path","text":"A string representing the path that was requested.","title":"path"},{"location":"reference/http/#headers","text":"A Headers object containing all request headers.","title":"headers"},{"location":"reference/http/#cookies","text":"A dict mapping str to str containing the cookies sent by the client.","title":"cookies"},{"location":"reference/http/#formrequest","text":"class FormRequest(path='/', body={}, boundary=None, *, method='GET', query=[], headers=[], **headers) A subclass of Request that encodes the provided body as multipart/form-data and sets the appropriate headers. Body must be a dict , an iterable of 2-tuples or a MultiDict where the keys are strings and the values are either strings or a File . If no boundary is supplied a boundary is automatically generated.","title":"FormRequest"},{"location":"reference/http/#jsonrequest","text":"class JsonRequest(path='/', body={}, *, method='GET', query=[], headers=[], **headers) A subclass of Request that encodes the provided body as application/json and sets the appropriate headers. Body must be data that is JSON-encodable.","title":"JsonRequest"},{"location":"reference/http/#textrequest","text":"class TextRequest(path='/', body='', *, method='GET', query=[], headers=[], **headers) A subclass of Request that encodes the provided body as text/plain and sets the appropriate headers. Body must be a string.","title":"TextRequest"},{"location":"reference/http/#response","text":"class Response(body=b'', *, status=200, content_type=None, charset=None, boundary=None, set_cookies=[], headers=[], **headers) Represents a response from the application to a client. Both query and headers expect a dict , an iterable of 2-tuples or a MultiDict . body can be bytes , an iterable of bytes or an async iterable of bytes . set_cookies expects an iterable of Cookie that will be added as Set-Cookie response headers. content_type , charset and boundary together determine the Content-Type header. If content_type starts with 'multipart/' we expect boundary to be present and add it to the Content-Type , otherwise charset gets added if present. This class implements Stream .","title":"Response"},{"location":"reference/http/#attributes_1","text":"","title":"Attributes"},{"location":"reference/http/#status","text":"An integer representing the HTTP status code of the response.","title":"status"},{"location":"reference/http/#headers_1","text":"A Headers object containing all response headers.","title":"headers"},{"location":"reference/http/#ok","text":"A boolean indicating whether the response is considered 'ok' according to the HTTP status code. This is implemented as status < 400 .","title":"ok"},{"location":"reference/http/#formresponse","text":"class FormResponse(body={}, boundary=None, *, status=200, content_type=None, charset=None, set_cookies=[], headers=[], **headers) A subclass of Response that encodes the provided body as multipart/form-data and sets the appropriate headers. Body must be a dict , an iterable of 2-tuples or a MultiDict where the keys are strings and the values are either strings or a File . If no boundary is supplied a boundary is automatically generated.","title":"FormResponse"},{"location":"reference/http/#htmlresponse","text":"class HtmlResponse(body='', *, status=200, content_type=None, charset=None, set_cookies=[], headers=[], **headers) A subclass of Response that encodes the provided body as text/html and sets the appropriate headers. Body must be a string.","title":"HtmlResponse"},{"location":"reference/http/#jsonresponse","text":"class JsonResponse(body={}, *, status=200, content_type=None, charset=None, set_cookies=[], headers=[], **headers) A subclass of Response that encodes the provided body as application/json and sets the appropriate headers. Body must be data that is JSON-encodable.","title":"JsonResponse"},{"location":"reference/http/#redirectresponse","text":"class RedirectResponse(location, *, status=304, content_type=None, charset=None, set_cookies=[], headers=[], **headers) A subclass of Response that represents a redirect to the provided location .","title":"RedirectResponse"},{"location":"reference/http/#textresponse","text":"class Response(body='', *, status=200, content_type=None, charset=None, set_cookies=[], headers=[], **headers) A subclass of Response that encodes the provided body as text/plain and sets the appropriate headers. Body must be a string.","title":"TextResponse"},{"location":"reference/http/#stream","text":"class Stream(chunks=b'') This is an abstract base class that represents something with a stream of binary data and a content type. It is mainly used as base class for both Request and Response .","title":"Stream"},{"location":"reference/http/#attributes_2","text":"","title":"Attributes"},{"location":"reference/http/#content_type","text":"The basic content type without any metadata like the charset.","title":"content_type"},{"location":"reference/http/#charset","text":"The charset of the content.","title":"charset"},{"location":"reference/http/#boundary","text":"The boundary of the content. This is mostly relevant for multipart content types.","title":"boundary"},{"location":"reference/http/#methods","text":"","title":"Methods"},{"location":"reference/http/#chunks","text":"method chunks() Returns an async iterator of chunks of data. These chunks will be of type bytes .","title":"chunks"},{"location":"reference/http/#body","text":"coroutine body() Returns the contents of the stream as bytes .","title":"body"},{"location":"reference/http/#text","text":"Returns the contents of the stream as a string.","title":"text"},{"location":"reference/http/#json","text":"Returns the contents of the stream parsed as json.","title":"json"},{"location":"reference/http/#form","text":"Returns the contents of the stream parsed as form data. How the stream is parsed is dependent on the content_type , both application/x-www-form-urlencoded and multipart/form-data are supported.","title":"form"},{"location":"reference/http/#socket","text":"class Socket(path='/', *, accept, close, receive, send, query=[], headers=[], **headers) Represents a websocket connection from a client to the application. Both query and headers expect a dict , an iterable of 2-tuples or a MultiDict . accept , close , receive , and send should be coroutines that respectively accept the connection, close the connection, receive a message from the socket or send a message to the socket.","title":"Socket"},{"location":"reference/http/#attributes_3","text":"","title":"Attributes"},{"location":"reference/http/#method_1","text":"This will always be equal to 'websocket' . This attribute is present to easily differentiate between Socket s and Request s.","title":"method"},{"location":"reference/http/#path_1","text":"A string representing the path that was requested.","title":"path"},{"location":"reference/http/#headers_2","text":"A Headers object containing all request headers.","title":"headers"},{"location":"reference/http/#cookies_1","text":"A dict mapping str to str containing the cookies sent by the client.","title":"cookies"},{"location":"reference/http/#methods_1","text":"","title":"Methods"},{"location":"reference/http/#accept","text":"coroutine accept(headers=[], set_cookies=[], **headers) Accepts the connection with the provided response headers. headers expects a dict , an iterable of 2-tuples or a MultiDict . set_cookies expects an iterable of Cookie that will be added as Set-Cookie response headers.","title":"accept"},{"location":"reference/http/#close","text":"coroutine close(code=1000) Closes the connection with the provided code .","title":"close"},{"location":"reference/http/#receive_bytes","text":"coroutine receive_bytes() Receive a message from the socket as bytes .","title":"receive_bytes"},{"location":"reference/http/#receive_text","text":"coroutine receive_text() Receive a message from the socket as str .","title":"receive_text"},{"location":"reference/http/#receive_json","text":"coroutine receive_bytes() Receive a message from the socket as parsed json.","title":"receive_json"},{"location":"reference/http/#send_bytes","text":"coroutine send_bytes(data) Sends data over the socket. data must be bytes .","title":"send_bytes"},{"location":"reference/http/#send_text","text":"coroutine send_bytes(data) Sends data over the socket. data must be str .","title":"send_text"},{"location":"reference/http/#send_json","text":"coroutine send_bytes(data) Sends data over the socket as JSON. data must be JSON encodable.","title":"send_json"},{"location":"reference/http/#cookie","text":"Cookie(name, value, *, expires=None, max_age=None, domain=None, path=None, secure=False, http_only=False, same_site=None) Represents a cookie that can be set. expires must be a timezone aware datetime or None . max_age must be an integer or None . domain must be a str or None . path must be a str or None . same_site must be one of 'lax' , 'strict' , 'none' or None .","title":"Cookie"},{"location":"reference/http/#attributes_4","text":"","title":"Attributes"},{"location":"reference/http/#expires","text":"A datetime indicating when the cookie will expire. Can also equal None in which case the cookie will expire at the end of the session.","title":"expires"},{"location":"reference/http/#max_age","text":"An int indicating when the cookie will expire. The cookie will expire max_age seconds after receival. Can also equal None in which case the cookie will expire at the end of the session.","title":"max_age"},{"location":"reference/http/#domain","text":"The domain for which the cookie should be set as a str . Can also equal None in which case the current domain will be used.","title":"domain"},{"location":"reference/http/#path_2","text":"The path for which the cookie should be set. Can also equal None in which case the root will be used.","title":"path"},{"location":"reference/http/#same_site","text":"A value indicating when to send the cookie. There are 3 options: strict , which means the cookie will only be sent on requests originating from the domain/path the cookie belongs to itself. lax , which is similar to strict but also includes the cookie when a user navigates to the domain/path. none , which does no checking on the origin of the request. Can also equal None in which case the cookie will behave as lax . On older clients the behaviour of none will be used instead when no value is present.","title":"same_site"},{"location":"reference/http/#methods_2","text":"","title":"Methods"},{"location":"reference/http/#encode","text":"method encode() Returns a str of the cookie encoded as the value of Set-Cookie -header.","title":"encode"},{"location":"reference/http/#disconnect","text":"class Disconnect(code=None) An exception that represents an HTTP Disconnect.","title":"Disconnect"},{"location":"reference/http/#attributes_5","text":"","title":"Attributes"},{"location":"reference/http/#code","text":"The websocket close code in a websocket context, otherwise None .","title":"code"},{"location":"reference/http/#asgi_to_jackie","text":"asgi_to_jackie(app) Converts an ASGI application app into a jackie view. If app was created by jackie_to_asgi it will return the original view instead.","title":"asgi_to_jackie"},{"location":"reference/http/#jackie_to_asgi","text":"asgi_to_jackie(view) Converts a jackie view view into an ASGI application. If view was created by asgi_to_jackie it will return the original application instead.","title":"jackie_to_asgi"},{"location":"reference/multidict/","text":"This module provides Mappings that allow multiple values per key which is a common pattern in HTTP. (headers, query parameters, form data, etc.) MultiDict class MultiDict(items=[], **items) A class that can be used as a mapping of keys to multiple values. The initial items can be supplied by an iterator of 2-tuples and/or keyword arguments. Methods All methods from collections.abc.MutableMapping are provided. Since these methods are all based on Mappings where keys have 1 value they when setting overwrite all values to the one value and when getting get the last value. getlist method getlist(key) Gets all values for a key. Returns a list. setlist method setlist(key, values) Sets all values for a key. values must be an iterable. appendlist method appendlist(key, value) Append a value to the existing values for a key. extendlist method extendlist(key, values) Extends the existing values for a key. values must be an iterable. poplist method poplist(key) Pops the last value from the values for a key. allitems method allitems() Returns an iterable of 2-tuples for all key value combinations. This differes from the standard items in that when a key has multiple values they will all appear in the iterable while the standard items would only include the last value. Headers class Headers(items=[], **items) A subclass of MultiDict that does some conversions on keys and values to have behaviour consistent with HTTP headers. Both keys and values should be of type str . bytes is automatically converted, other types will error. Keys are lowercased to ensure case insensitive behaviour.","title":"jackie.multidict"},{"location":"reference/multidict/#multidict","text":"class MultiDict(items=[], **items) A class that can be used as a mapping of keys to multiple values. The initial items can be supplied by an iterator of 2-tuples and/or keyword arguments.","title":"MultiDict"},{"location":"reference/multidict/#methods","text":"All methods from collections.abc.MutableMapping are provided. Since these methods are all based on Mappings where keys have 1 value they when setting overwrite all values to the one value and when getting get the last value.","title":"Methods"},{"location":"reference/multidict/#getlist","text":"method getlist(key) Gets all values for a key. Returns a list.","title":"getlist"},{"location":"reference/multidict/#setlist","text":"method setlist(key, values) Sets all values for a key. values must be an iterable.","title":"setlist"},{"location":"reference/multidict/#appendlist","text":"method appendlist(key, value) Append a value to the existing values for a key.","title":"appendlist"},{"location":"reference/multidict/#extendlist","text":"method extendlist(key, values) Extends the existing values for a key. values must be an iterable.","title":"extendlist"},{"location":"reference/multidict/#poplist","text":"method poplist(key) Pops the last value from the values for a key.","title":"poplist"},{"location":"reference/multidict/#allitems","text":"method allitems() Returns an iterable of 2-tuples for all key value combinations. This differes from the standard items in that when a key has multiple values they will all appear in the iterable while the standard items would only include the last value.","title":"allitems"},{"location":"reference/multidict/#headers","text":"class Headers(items=[], **items) A subclass of MultiDict that does some conversions on keys and values to have behaviour consistent with HTTP headers. Both keys and values should be of type str . bytes is automatically converted, other types will error. Keys are lowercased to ensure case insensitive behaviour.","title":"Headers"},{"location":"reference/multipart/","text":"This module provides some utility classes for working with multipart form data. File class File(name, content_type, content) This class is used to represent a file in multipart form data. name must a be string representing the file name. content_type must be a string comparable to a Content-Type request header. Notably this includes metadata like charset and boundary . content must be the contents of the file as bytes . Attributes name The name of the file. content_type The basic content type without any metadata like the charset. charset The charset of the content. boundary The boundary of the content. This is mostly relevant for multipart content types. content The contents of the file as bytes .","title":"jackie.multipart"},{"location":"reference/multipart/#file","text":"class File(name, content_type, content) This class is used to represent a file in multipart form data. name must a be string representing the file name. content_type must be a string comparable to a Content-Type request header. Notably this includes metadata like charset and boundary . content must be the contents of the file as bytes .","title":"File"},{"location":"reference/multipart/#attributes","text":"","title":"Attributes"},{"location":"reference/multipart/#name","text":"The name of the file.","title":"name"},{"location":"reference/multipart/#content_type","text":"The basic content type without any metadata like the charset.","title":"content_type"},{"location":"reference/multipart/#charset","text":"The charset of the content.","title":"charset"},{"location":"reference/multipart/#boundary","text":"The boundary of the content. This is mostly relevant for multipart content types.","title":"boundary"},{"location":"reference/multipart/#content","text":"The contents of the file as bytes .","title":"content"},{"location":"reference/router/","text":"This method provides a class that makes it easy to create a routed ASGI application that uses the HTTP API of jackie.http for the implementation of it's endpoints. Router class Router() A class that can be used as an ASGI application. Methods route method route(methods, matcher, view=None, *, name=None) Registers a view to the router for the given methods and matcher. methods must be a set of HTTP methods as uppercase strings or 'WEBSOCKET' . If methods is a str it will be interpreted as if it was a set with that string as it's only item. matcher must be an instance of Matcher . If matcher is a str it will be used as pattern to create a Matcher . view must be a callable using the HTTP API provided by jackie.http . If view is None this method will return a decorator that can be used to register such a view while leaving the original view unmodified. name is an optional str that can be used to reverse urls using the reverse method. include method include(matcher, router, *, name=None) Includes another router inside the router, the matcher here works as a prefix. The subrouter's error handling views will be ignored. matcher must be an instance of Matcher . If matcher is a str it will be used as pattern to create a Matcher . router must be an instance of Router . name is an optional str that can be used to reverse urls using the reverse method. not_found method not_found(view) Registers a view to be used in case no view could be found for the provided path. method_not_allowed method method_not_allowed(view) Registers a view to be used in case there were views found but not for the right method. websocket_not_found method websocket_not_found(view) Registers a view to be used in case no view could be found for a websocket connection. middleware method middleware(middleware) Registers middleware. middleware is a function that takes a view and returns a view. This wrapper will be used on every request. get method get(matcher, view=None, *, name=None) A shorthand for route where methods is filled as 'GET' . post method post(matcher, view=None, *, name=None) A shorthand for route where methods is filled as 'POST' . put method put(matcher, view=None, *, name=None) A shorthand for route where methods is filled as 'PUT' . delete method delete(matcher, view=None, *, name=None) A shorthand for route where methods is filled as 'DELETE' . connect method connect(matcher, view=None, *, name=None) A shorthand for route where methods is filled as 'CONNECT' . options method options(matcher, view=None, *, name=None) A shorthand for route where methods is filled as 'OPTIONS' . trace method trace(matcher, view=None, *, name=None) A shorthand for route where methods is filled as 'TRACE' . patch method patch(matcher, view=None, *, name=None) A shorthand for route where methods is filled as 'PATCH' . websocket method websocket(matcher, view=None, *, name=None) A shorthand for route where methods is filled as 'WEBSOCKET' . reverse method reverse(name, **params) Reverses a url for the given name with the provided params as parameters. name refers to the name used in the route method. For matching a route inside a named subrouter from include names must be joined with a : . Matcher class Matcher(pattern='') A helper class for matching paths and extracting parameters from them. pattern is a string that looks like the path. Parameters are delimited by < and > and should contain the name of the parameter. You can optionally specify the type of the parameter by adding a : and the name of the type after the parameter. Available types are str , int and path . Path differs from str in that / is not allowed in str while it is in path . If no type is provided str is assumed. Some examples: - '/user/<id:int>/' - '/file/<path:path>' - '/compare/<left>/to/<right>/' Methods __add__ Matchers can be added to get one big matcher which matches the two matchers in sequence. fullmatch method fullmatch(path) Tries to match the path to the matcher. In case of a match returns a dict containing all matched parameters. If the path does not match this will throw a Matcher.Error . match method match(path) Similar to fullmatch but also returns succesfully if only a prefix of the path matches instead of the entire path. Instead of a dict of params this method will return a 2-tuple consisting of the dict of params and the part of path that was not used in the match. reverse method reverse(**params) Returns a path that would match using the provided params . Matcher.Error class Matcher.Error() A subclass of ValueError that is used to indicate a failed match.","title":"jackie.router"},{"location":"reference/router/#router","text":"class Router() A class that can be used as an ASGI application.","title":"Router"},{"location":"reference/router/#methods","text":"","title":"Methods"},{"location":"reference/router/#route","text":"method route(methods, matcher, view=None, *, name=None) Registers a view to the router for the given methods and matcher. methods must be a set of HTTP methods as uppercase strings or 'WEBSOCKET' . If methods is a str it will be interpreted as if it was a set with that string as it's only item. matcher must be an instance of Matcher . If matcher is a str it will be used as pattern to create a Matcher . view must be a callable using the HTTP API provided by jackie.http . If view is None this method will return a decorator that can be used to register such a view while leaving the original view unmodified. name is an optional str that can be used to reverse urls using the reverse method.","title":"route"},{"location":"reference/router/#include","text":"method include(matcher, router, *, name=None) Includes another router inside the router, the matcher here works as a prefix. The subrouter's error handling views will be ignored. matcher must be an instance of Matcher . If matcher is a str it will be used as pattern to create a Matcher . router must be an instance of Router . name is an optional str that can be used to reverse urls using the reverse method.","title":"include"},{"location":"reference/router/#not_found","text":"method not_found(view) Registers a view to be used in case no view could be found for the provided path.","title":"not_found"},{"location":"reference/router/#method_not_allowed","text":"method method_not_allowed(view) Registers a view to be used in case there were views found but not for the right method.","title":"method_not_allowed"},{"location":"reference/router/#websocket_not_found","text":"method websocket_not_found(view) Registers a view to be used in case no view could be found for a websocket connection.","title":"websocket_not_found"},{"location":"reference/router/#middleware","text":"method middleware(middleware) Registers middleware. middleware is a function that takes a view and returns a view. This wrapper will be used on every request.","title":"middleware"},{"location":"reference/router/#get","text":"method get(matcher, view=None, *, name=None) A shorthand for route where methods is filled as 'GET' .","title":"get"},{"location":"reference/router/#post","text":"method post(matcher, view=None, *, name=None) A shorthand for route where methods is filled as 'POST' .","title":"post"},{"location":"reference/router/#put","text":"method put(matcher, view=None, *, name=None) A shorthand for route where methods is filled as 'PUT' .","title":"put"},{"location":"reference/router/#delete","text":"method delete(matcher, view=None, *, name=None) A shorthand for route where methods is filled as 'DELETE' .","title":"delete"},{"location":"reference/router/#connect","text":"method connect(matcher, view=None, *, name=None) A shorthand for route where methods is filled as 'CONNECT' .","title":"connect"},{"location":"reference/router/#options","text":"method options(matcher, view=None, *, name=None) A shorthand for route where methods is filled as 'OPTIONS' .","title":"options"},{"location":"reference/router/#trace","text":"method trace(matcher, view=None, *, name=None) A shorthand for route where methods is filled as 'TRACE' .","title":"trace"},{"location":"reference/router/#patch","text":"method patch(matcher, view=None, *, name=None) A shorthand for route where methods is filled as 'PATCH' .","title":"patch"},{"location":"reference/router/#websocket","text":"method websocket(matcher, view=None, *, name=None) A shorthand for route where methods is filled as 'WEBSOCKET' .","title":"websocket"},{"location":"reference/router/#reverse","text":"method reverse(name, **params) Reverses a url for the given name with the provided params as parameters. name refers to the name used in the route method. For matching a route inside a named subrouter from include names must be joined with a : .","title":"reverse"},{"location":"reference/router/#matcher","text":"class Matcher(pattern='') A helper class for matching paths and extracting parameters from them. pattern is a string that looks like the path. Parameters are delimited by < and > and should contain the name of the parameter. You can optionally specify the type of the parameter by adding a : and the name of the type after the parameter. Available types are str , int and path . Path differs from str in that / is not allowed in str while it is in path . If no type is provided str is assumed. Some examples: - '/user/<id:int>/' - '/file/<path:path>' - '/compare/<left>/to/<right>/'","title":"Matcher"},{"location":"reference/router/#methods_1","text":"","title":"Methods"},{"location":"reference/router/#__add__","text":"Matchers can be added to get one big matcher which matches the two matchers in sequence.","title":"__add__"},{"location":"reference/router/#fullmatch","text":"method fullmatch(path) Tries to match the path to the matcher. In case of a match returns a dict containing all matched parameters. If the path does not match this will throw a Matcher.Error .","title":"fullmatch"},{"location":"reference/router/#match","text":"method match(path) Similar to fullmatch but also returns succesfully if only a prefix of the path matches instead of the entire path. Instead of a dict of params this method will return a 2-tuple consisting of the dict of params and the part of path that was not used in the match.","title":"match"},{"location":"reference/router/#reverse_1","text":"method reverse(**params) Returns a path that would match using the provided params .","title":"reverse"},{"location":"reference/router/#matchererror","text":"class Matcher.Error() A subclass of ValueError that is used to indicate a failed match.","title":"Matcher.Error"}]}